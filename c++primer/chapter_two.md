第六章 函数

## 6.1 基础概念

* 函数的调用完成两项任务：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。
* 函数的返回值类型不能是数组和函数类型，但是可以是指向数组或函数的指针
* 实参与形参的区别：实参是形参的初始值

### 6.1.1 局部对象

* c++中名字有作用域，对象有生命周期
* 函数体是一个语句块，块构成一个新的作用域   只存在块执行期间的对象称为自动对象
* 形参和函数体内部定义的变量统称为`局部变量`
* 内置类型的未初始化局部变量将产生未定义的值（所以局部变量要赋初值）
* 为了让局部变量的生命周期贯穿函数调用前后，可将局部变量定义为static类型
* **局部静态对象**在程序第一次经过对象定义语句时初始化，并直到程序终止才销毁。在此期间，即使函数结束执行也不会对其有影响。
* 内置类型的局部静态变量初始化为0

### 6.1.2 函数声明

* 函数只能定义一次，但可以声明多次
* 函数的名字必须在使用前声明    函数的声明无须函数体，用一个分号替代即可
* 在函数声明中经常省略形参的名字（因为没有函数体，有名字也没用呀），但是形参的类型不能省略哦
* 函数也应该在头文件中声明而在源文件中定义

### 6.1.3 分离式编译

* 分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译

* fact.h 保存函数的声明  fact.cpp保存函数的定义  fact main.cpp编写的是main函数，其调用fact中的函数，编译过程如下：

  ```c++
  g++ factmain.cpp fact.cpp -o factmain
  ./factmain
  ```

  如果修改了其中一个源文件，则只需重新编译那个改动了的文件

  ```c++
  g++ -c fact.cpp //得到fact.o文件  编译
  g++ -c factmain.cpp //得到factmain.o文件
  g++ fact.o factmain.o -o factmain  //链接形成factmain可执行文件
  ./factmain
  ```



## 6.2 参数传递 

### 6.2.1 复合类型（compound type）

* 复合类型是指基于其他类型定义的类型 （这里先只了解 引用和指针）
* 一条声明语句由一个`基本数据类型`和一个`声明符列表`组成  声明符可以为变量名也可以为更复杂的声明符

#### 引用

* **引用**为对象起了另外一个名字 通过将声明符写成`&变量名`的形式来定义引用类型

  ```c++
  int ival = 1024;
  int &refval = ival;
  int &refval1; //报错 引用必须初始化
  int &refval2 = ival, refval3 = ival; //refval2是引用 refval3是int
  ```

  定义引用时，程序将引用和初始值绑定在一起，而不是初始值拷贝给引用。一旦初始化完成，引用和它的初始值对象一直绑定在一起，无法重新绑定到另一个对象上，所以引用必须初始化。

* 引用并非对象，它只是为一个已经存在的对象所起的另一个名字。为引用赋值，实际上就是把值赋给了与引用绑定的对象

* 引用可以绑定到引用上。其实际是以与引用绑定的对象作为初始值

* 由于引用本身不是一个对象，所以不能定义引用的引用。(这里不是说引用不能用引用赋值，而是这样的)

  ![Screenshot 2020-12-04 at 10.35.09 AM](/Users/yannie/Desktop/c++primer/chapter_six/reference.jpg)

* 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定在一起

  ```c++
  int &refval = 10; //错的！！！
  double dval = 3.14;
  int &refval5 = dval; //错误！ 此时初始值必须为int型对象
  ```

#### 指针

* 指针是“指向”另一种类型的复合类型。
* 指针与引用不同之处：
  1. 指针本身是一个对象，允许对指针赋值和拷贝
  2. 在指针生命周期内，其可先后指向几个不同的对象
  3. 指针无需在定义时赋初值，但是其将拥有一个不确定的值。(但建议初始化所有指针)

* 通过将声明符写成`*变量名`的形式来定义指针类型

* 指针存放某个对象的地址，想要获取地址要用取地址符（&） 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针

  ```c++
  int val = 42;
  int *p = &val;
  ```

* 如果指针指向了一个对象，则允许使用解引用符(*)来访问该对象

  ```c++
  cout << *p; //输出42
  ```

* 在试图使用一个指针之前，代码可以首先检查其是否为空

  - 得到空指针最直接的办法就是用字面值**nullptr**来初始化指针，nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。
  - 过去使用一个预处理变量**NULL**来给指针赋值，预处理器是运行于编译过程之前，所以其不属于命名空间std，则无须在前面加上std::

* 赋值永远改变的是等号左侧的对象

  ```c++
  int * pi = 0;
  pi = &val; // pi的值被改变了，其现在指向val
  * pi = 0; //val的值改变了，指针pi并没有改变
  ```

* 任何非0指针对应的条件值都是true

* void* 是一种特殊的指针类型，其可存放任意对象的地址。但不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型

* 声明符列表

  ```c++
  int i = 1024, *p = &i, &r = i; //i是一个int型的数 p是一个int型指针 r是一个int型引用
  ```

  int 是基本数据类型， 后面的 i *p  &r 只不过是声明符的一部分

* 通过*个数可以区分指针的级别   **表示指针的指针（因为指针本身是一个对象，其也有地址）

* 解引用指向指针的指针会得到一个指针

  ```c++
  int ival = 1024;
  int *pi = &ival;  int **ppi = &pi;
  cout << **ppi;  cout << *pi;
  ```

* 指向指针的应用

```c++
int i = 42; int *p ;  int *&r = p; 
r = &i; //r引用了一个指针，则给r赋值&i就是令p指向i
*r = 0; //解引用r得到i，将i的值改为0
```

* **要理解 r 类型到底是什么，从右向左阅读 r 的定义，离变量名最近的符号对变量的类型有最直接的影响。声明符其他部分用以确认r引用的类型是什么，最后声明符的基本数据类型部分指出r引用的是一个int型指针**

```c++
int *&r = p; //因此这里r是一个引用 声明符剩余的*表明r引用的是一个指针
```

### 6.2.2 基本概念

* 形参的类型决定了形参与实参交互的方式。若形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋值给实参
* 当形参是引用类型时，其对应的实参被**引用传递** 。 引用形参是它对应的实参的别名。
* 当实参的值被拷贝给形参的时候，形参和实参是两个独立的对象。此时实参被**值传递**。

### 6.2.3 传值参数

* 此时形参对变量的改动不会影响初始值实参
* 指针形参也是值传递，其传递时拷贝的是指针的值，拷贝之后，两个指针是不同的指针。但可以通过指针修改它所指对象的值。

```c++
void reset(int *ip){
	*ip = 0;
	ip = 0;
}

int main(int argc, char const *argv[])
{
	int i = 42;
	std::cout << &i << std::endl;
	reset(&i);
	std::cout << i << std::endl;
	std::cout << &i << std::endl;
	return 0;
}
```

![运行结果](/Users/yannie/Desktop/c++primer/chapter_six/zhizhen.jpg)

### 6.2.4 使用引用避免拷贝

* 拷贝大的类类型对象或者容器对象太低效了，设置有的类类型（如IO类型）不支持拷贝，此时只能用引用形参来访问该类型的对象。
* 当函数无须修改引用形参值的时候，最好使用常量引用。
* 使用引用形参可以返回额外的信息 

### 6.2.5 const形参和实参 

#### const限定符用法回顾

* const对象一旦创建后其值就不能再改变，所以const对象必须初始化，其初始值可以是任意复杂的表达式

* const对象被设定为仅在文件内有效。当多个文件中出现了同名const变量时，其等同于在不同文件中定义了独立的变量。

* 当const变量初始值不是一个常量表达式时，若要在文件中共享const变量，可以在其声明和定义的部分都添加extern关键字。

* const的引用（也叫对常量的引用）

  ```c++
  const int ci = 1024; const int &r1 = ci;
  r1 = 42; //错误 r1是对常量的引用
  int &r2 = ci; //错误 让一个非常量引用指向一个常量对象
  ```

  ```c++
  double dval = 3.14;  const int &ri = dval; //不会报错
  ```

  编译器优化如下：

  ```c++
  const int temp = dval; //生成一个临时的整型常量  
  const int &ri = temp; //ri绑定了一个临时量对象。 临时量对象是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象
  ```

  但当为

  ```c++
  double dval = 3.14;   int &ri = dval; //会报错
  ```

  因为此时ri绑定的是一个临时量而并非dval（按道理此时应该ri值为3，因为临时量值为int型，截断为3），而既然想要让ri绑定dval，就肯定是想用ri修改dval的值，这里根本没法做到，所以就是非法行为。

* 对const的引用可以绑定一个非常量数，但const数不能绑定到一个非const的引用上

  ```c++
  int i = 42; int &r1 = i; const int &r2 = i;
  //r2不能修改i的值，但是i的值可以由r1修改
  ```

#### 指针和const

* 要想存放常量对象的地址，只能使用指向常量的指针
* const指针：把*放在const关键字之前用以说明指针是一个常量

```c++
int err = 0;  int *const curErr = &err; //curErr将一直指向err
```

这样书写也表明，不变的是指针本身的值，而并非指向的那个值

从右往左读，const表示curErr本身是一个常量对象，对象类型由声明符其余部分确定。声明符中下一个是*，表示其为一个常量指针。声明语句中的基本数据类型int表示常量指针指向的是一个int对象。

* 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全取决于所指对象的类型。

#### 顶层const

* 使用**顶层const**表示指针本身是一个常量  **底层const**表示指针所指的对象是一个常量

  ```c++
  const int ci = 42;
  const int *p2 = &ci; //允许改变p2的值，这是一个底层const
  //从右往左看，它首先是一个指针对象，声明符剩余的部分表示对象类型，其是一个指向常量int型数的指针
  const int *const p3 = p2; //靠右的const是顶层const，靠左的是底层const
  const int &r = ci; //用于声明引用的const都是底层const
  ```

  * 拷贝的时候顶层const不受什么影响，底层const却有所限制（非常量可以转化成常量，而常量不能转化成非常量）

  #### 常量表达式

  * 常量表达式表示值不会改变并且在编译过程就能得到计算结果的表达式

    ```c++
    const int max_files = 20; //是常量表达式
    int staff_size = 27; //不是常量表达式 因为其数据类型不是 const int
    const int sz = get_size(); //不是常量表达式 因为它的具体值直到运行时才能获得到
    ```

  * 将变量声明为`constexpr`类型，以便编译器来检验变量的值是否为一个常量表达式

  * 在constexpr声明中如果定义了一个指针，限定符constexpr仅和指针有关，与指针所指对象无关

#### 指针或引用形参与const

* 当形参有顶层const时，传给它常量对象或者非常量对象都是可以的

  ```c++
  void fcn(const int i);
  void fcn(int i); //不合法 因为在上一行中顶层const被忽略了 跟这一行表达的意思就一样了
  ```

* c++允许用字面值初始化常量引用

* 尽量使用常量引用

  - 函数不可以修改其值
  - const对象，字面值等不能传递给普通的引用形参 但常量引用可以

### 6.2.6 数组形参

* 数组两个性质：不允许拷贝数组 / 使用数组时会将其转化成指针

  ```c++
  void print(const int*);
  void print(const int []); //这两种写法等价
  ```

* 标记数组长度的方法（使用标准库规范/显示传递一个表示数组大小的形参）

```c++
void print(const int *beg, const int *end){
  while(beg != end)
    cout << *beg++ << endl;
}
void print(const int ia[], size_t size){ }
```

* c++函数的形参可以是数组的引用，此时引用形参绑定到对应的实参上，也就绑定到数组上了

```c++
void print( int (&arr)[10] ) { } //arr是具有10个整数的整型数组的引用
void print( int &arr[10] ){ } //arr是引用的数组
```

* 传递多维数组

  ```c++
  void print( int (*matrix)[10], int rowsize ){ } //*matrix两端括号不能少
  void print( int matrix[][10], int rowsize ){ }
  ```

### 6.2.7 main: 处理命令行选项

```c++
int main(int argc, char const *argv[]){ }
```

### 6.2.8 列表初始化

 C++初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。

```c++
class  CMyClass  {
    CMyClass(int x, int y);
    int m_x;
    int m_y;
} ;

CMyClass::CMyClass( int  x,  int  y) : m_y(y), m_x(m_y)
 { }
```

你可能以为上面的代码将会首先做m_y=y，然后做m_x=m_y，最后它们有相同的值。但是编译器先初始化m_x，然后是m_y,，因为它们是按这样的顺序声明的。结果是m_x将有一个不可预测的值。

### 6.2.9 含有可变形参的函数

```c++

void error_msg( initializer_list<string> il ){

    for( auto beg = il.begin(); beg != il.end(); ++beg )
        cout << *beg << " ";
    cout << endl;
}
int main() {
    string expected = "ok";
    error_msg( {"function", expected, "haha"} );
    error_msg( {"function", "wrong" } );
    return 0;

}
```



## 6.3 返回类型

### 有返回值函数

* 只要函数的返回类型不是void，则函数内每条return语句必须返回一个值
* 在含有return语句的循环后面应该也有一条return语句，很多编译器无法发现这个错误（leetcode上的可以发现这个错误。。。）
* 函数返回的值用于初始化调用点的一个临时量（即调用点会创建一个临时变量来存储这个返回值，然后再将其赋值给赋值符号左边的变量）
* 如果函数返回引用，则引用仅是它所引对象的一个别名，并不是拷贝该对象。
* 不要返回局部对象的引用或指针(局部对象返回其实是不报错的)

```c++
const string &manip(){ //一切问题出在返回值是引用 因为函数结束时临时对象占用的空间也就随之释放
  string ret; //这一句然后改变ret的值
  if( !ret.empty() ) return ret; //错误 返回局部对象的引用 直接报错无法返回
  else return "Empty"; //错误 “Empty”是一个局部临时变量 (但是可以输出正确结果)
//这里字符串字面值转换成一个局部临时string对象，对于mainip来说其和ret一样是局部的
}
```

* `函数返回局部对象`这个问题以后探讨

### 返回类类型函数和调用运算符

* 如果函数返回指针，引用或类的对象，则可以使用函数调用的结果访问结果对象的成员

  ```c++
  string s = Solution().getminstring("sahduibvuibne"); //这个应该跟这里说的不一样
  ```

* 如果函数返回值是引用，则这个值是左值，其他的值是右值

* 列表初始化返回值，即函数返回用花括号包围的值的列表

  ```c++
  vetcor<int> findnum( ){
    return {1,2}; //类似于这种
  }
  ```

* main函数返回0表示执行成功，返回其他值都认为是失败

### 返回数组指针

* 因为数组不能被拷贝（这里指不能直接用赋值符号将一个数组拷贝给另一个数组,但vector可以哦），所以函数不能返回数组，但是可以返回数组的指针或引用。

* 使用类型别名来返回数组的指针或引用

  ```c++
  typedef int arrT[10] ; //arrT是一个类型别名，它表示的类型是含有10个整数的数组
  using arrT = int[10]; //使用using来给int[10]声明一个别名 arrT
  arrT* func(int i); //返回一个指向含有10个整数的数组的指针 
  ```

* 声明一个返回数组指针的函数

  ```c++
  int (*func(int i))[10]; 
  ```

* 使用尾置返回类型，尾置返回类型跟在形参列表后面并以一个**->**符号开头，在本该出现返回类型的地方用auto。这种返回方式适合返回类型比较复杂的函数，如数组的指针或引用。

  ```c++
  //func 接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
  auto func(int i) -> int(*)[10];
  ```

* 使用decltype关键字

```c++
int odd[] = {1,3,5,7}; int even[] = {2,4,6,8};
decltype(odd) *arrPtr(int i)  //arrPtr返回一个指向含有5个整数的数组的指针
  return (i%2) ? &odd : &even;
```

## 6.4 函数重载

* 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现重载

```c++
Record lookup(Account&);
Recore lookup(const Account&); //这个顶层和底层const好容易忘记。。。
```

* const_cast

## 6.5 c++的特殊语言特性

### 默认实参

```c++
string screen( size_type ht = 24, size_type wid = 80, char background = '' ); //为每一个形参都提供了默认的实参,某个形参赋了默认值之后，其后的所有形参都必须有默认值 而其前面的不要求
```

* 在调用的时候，只可以省略尾部的实参  所以在设计含有默认实参的函数时，尽量让经常使用默认值的形参出现在后面

```c++
window = screen(, , '?'); //这样都不可以
```

### 内联函数和constexpr函数

* 内联函数可以避免函数调用的开销
* 在函数返回类型前面加上关键字 inline  内联机制用于优化规模较小，流程直接，频繁调用的函数
* constexpr函数是指能用于常量表达式的函数
* 内联函数和constexpr函数通常定义在头文件中

### assert预处理宏

* assert宏定义在cassert头文件中，预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无需提供using声明

### NDEBUG预处理变量

* 我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态
* 定义NDEBUG能避免检查各种条件所需的运行时开销
* `__func__` 是编译器定义的一个局部静态变量，用于存放函数的名字
* `__FILE__`存放文件名的字符串字面值
* `__LINE__`存放当前行号的整型字面值
* `__TIME__`存放文件编译时间的字符串字面值
* `__DATE__`存放文件编译日期的字符串字面值

## 6.6 函数匹配 

* 未仔细看 243页

## 6.7函数指针

* 想要声明一个可以指向该函数的指针，只需要用指针替换函数名即可
* 248页















































c++就带着学，每天看一个几点几



# 第7章

## 7.1 定义抽象数据类型

### 基础概念

* 类的基本思想是`数据抽象`和`封装`  （首先要定义一个抽象数据类型）
* `数据抽象`是一种依赖于`接口`和`实现`分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括`类的成员`，负责接口实现的`函数体`以及定义类所需要的各种`私有函数`。
* `封装`实现了类的`接口`和`实现`的分离。封装后的类隐藏了它的实现细节。即类的用户只能使用接口而无法访问实现部分
* 类的用户可以直接访问它的数据成员的不是抽象数据类型。
* 定义在类内部的函数是隐式的inline函数
* 成员函数的声明必须在类的内部，但是定义不一定要在内部，也可以在外部

```c++
class Sales_data{
  std::string isbin( ) const { return bookNo; } //定义和声明都在内部
  Sales_data &combine( const Sales_data& ); //只有声明在内部
  double avg_price() const; //只有声明在内部
  std::string bookNo;
};
Sales_data add( const Sales_data&, const Sales_data& ); //Sales_data的非成员接口函数
```

* isbin()函数中，其返回的是Sales_data对象的bookNo数据成员。但是其是如何获得bookNo成员所依赖的对象的呢？

```c++
total.isbin();
//通过点运算符来访问total对象的isbin成员  当调用成员函数时，实际上是在替某个对象调用它
//这里isbin指向类的成员bookNo，则它其实隐式地指向调用isbin的类的对象的成员 这里是isbin返回bookNo时，实际上隐式地返回total.bookNo
```

### this指针

* 成员函数通过一个名为this的额外的隐式参数 来访问 调用它的那个对象，这里指isbin函数通过隐式参数this来访问total
* 如果调用**total.isbin() **编译器会负责把`total的地址`传给isbin的`隐式形参this` ，可以等价为下面这种形式

```c++
total.isbin(); //原来的
Sales_data::isbin(&total) //调用isbin成员时传入了total的地址
```

* 在成员函数内部，可以直接调用成员，而不需要用成员访问符，就是因为this所指的正是这个对象。 任何对类成员的直接访问都被看作this的隐式引用。

```c++
std::string isbin( ) const { return bookNo; }
```

* 这里的const关键字放在成员函数的参数列表之后，表示this是一个指向常量 的指针，这样就可以把this绑定到一个常量对象上，即一个常量对象上就可以调用普通的成员函数。 使用const的成员函数叫做**常量成员函数**

### 类作用域和成员函数

* 编译器会首先编译成员的声明，然后才轮到成员函数体。因此成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序。

* 在类外部定义的成员函数，其函数名必须包含它所属的类名：

  ```c++
  double Sales_data::avg_price() const { 
    if( units_sold)
      return revenue / units_sold;
  }
  ```

  编译器一看到这个函数名，就能理解剩余代码是位于类的作用域内的。因此，当avg_price使用 revenue和units_sold时，实际上它隐式地使用了类的成员

### 定义一个返回this对象的函数

![Screenshot 2020-12-12 at 10.34.55 PM](/Users/yannie/Desktop/Screenshot 2020-12-12 at 10.34.55 PM.png)

(要仔细看啊，很重要的这一个小知识点)

* 非成员函数是类接口的组成部分，这些函数的声明（非定义）应该与类在同一个头文件内

![Screenshot 2020-12-12 at 10.38.20 PM](/Users/yannie/Library/Application Support/typora-user-images/Screenshot 2020-12-12 at 10.38.20 PM.png)

* 默认情况下，拷贝类的对象其实拷贝的是对象的数据成员

### 构造函数

* 构造函数不能被声明为const类型。当创建类的一个const对象时，指导构造函数完成初始化过程，对象才能取得真正常量的属性，也就是说，构造函数在const对象的构造过程中可以向其写值。
* 指针和数组等复合类型或内置类型的对象被默认初始化的话，它们的值是未定义的。
* 构造函数初始值列表

```c++
Sales_data(const std::string &s, unsigned n) : bookNo (s),units_sold(n) { }
```

* c++中拷贝对象的情况：初始化变量  以值的方式传递或返回一个对象。 如果使用“=”号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右边的初始值拷贝到新创建的对象中去，与之相反，如果不使用等号，则执行是直接初始化。

## 7.2 访问控制与封装

* 可以用class或struct中的任意一个定义类。但struct的成员访问权限默认为public，而class的成员访问权限默认为private
* 类可以允许其他类或者函数访问它的非公有成员，只要将其他类或者函数的**声明**为它的**友元(friend)**，只是声明部分需要加 friend哦，定义部分不用加
* 友元的声明仅仅指定了访问权限，而非一个通常意义上的函数声明。如果想要调用这个友元函数，应该再对该函数进行一次声明
* 通常将友元的声明与类本身放置在同一个头文件中，但是在类的外部















