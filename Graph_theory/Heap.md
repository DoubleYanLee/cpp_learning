## 第四章 堆和堆排序

### 优先队列

* 出队顺序和入队顺序无关；和优先级相关
* 在1000000个元素中选出前100名
* 优先队列的底层实现如果用堆的话，可以将入队和出队的时间复杂度都降低到O(lgn)

### 二叉堆是一棵完全二叉树

* 堆总是一棵完全二叉树
* 堆中某个节点的值总是不大于/小于其父节点的值
* 用数组来存储二叉堆（因为父节点和左右孩子节点的索引有规律）
* 一般的话将堆下标记按照1开始，存放在数组索引为1的地方，索引为0的地方不用它

### Shift Up  向一个最大堆中添加元素

* 将插入的节点逐一和父亲节点相比较，层层向上移动

### Shift Down 从堆中取出一个元素

* 只能取出堆顶部的元素，然后将堆中最后一个元素放到顶部，将这个元素再层层下移（和左右子孩子中较大的那个进行交换）

### Heapify 给定一个数组让其构造成堆

* 从堆中第一个非叶子结点的元素开始进行shiftdown操作，即将其局部看作一个小的堆
* 将n个元素逐个插入到一个空堆中，算法复杂度是O(nlogn) 。 heapify过程，算法复杂度是O(n)

### 原地堆排序

* 每次将数组第一个元素（最大的元素）和数组末尾的元素交换一下，然后前面的部分可以轻易的shiftdown一下，然后再交换，这样就不用开辟一个新的空间来存排序后的数组了

### 索引堆 IndexHeap

#### 原来的堆的缺点

* 如果数组中每个元素的类型本身就很复杂的话，交换这些元素本身消耗就很多。
* 很难通过索引去获得一个值，也就是堆中的元素很难改变了

### 索引堆

* 堆中存的是索引（多了一个索引数组），而不是值。在排序之后，数组中元素的位置并没有变化，而是索引的位置发生了变化
*  在修改元素后维护堆的过程中优化查找的方法 ： 反向查找：rev[i] 表示i这个索引在数组中的位置是什么

### 和堆相关的问题

* 使用堆来实现优先队列
* 游戏中实现一个人物的攻击范围的堆中
* 在N个元素中选出前M个元素
* 多路归并排序 （将每一路的元素推入堆中，将堆顶最大的元素推出后，将推出的那一路中元素加入堆中） 选择这个路数是一个平衡 
* d叉堆  d-ary heap  d的这个选择也是一个性能的平衡
* 最大/最小索引堆  堆的数组从0开始索引
* ShiftUp  ShiftDown 中使用复制操作替换swap操作
* 最大最小队列, 这个队列既能很快找到最大元素，又能很快找到最小元素
* 二项堆 斐波那契堆



